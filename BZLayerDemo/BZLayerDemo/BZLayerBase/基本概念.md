#  layer基本概念

首先先了解一下UIView的相关知识，我们在iOS中可以看到的所有视图都是由UIView的派生类而来，UIView支持时间响应，CG绘图，以及各种动画，那么CALayer和和UIView有什么关系呢？

两者在概念上很相似，都是被**层级管理树**管理的一些矩形块，同样可以包含内容，管理子图层，可以做动画和变换，最大的不同就是UIView可以处理事件，但是layer则不行，即使它提供了一些触点是否在图层范围内的方法。

除了以上这些，最重要的一点就是每个UIView视图内部都封装了一个CALayer图层，可以通过这个layer这个属性访问这个图层。对于UIView来说，真正负责展示的其实是他内部的CALayer，UIView只不过将自身展示的任务交给了内部的CALayer来完成，而且它还肩负着一些其他的任务，比如说用户的交互响应，提供一些Core Animation的底层方法的高级接口。

这种分层模式很重要，这样做极大程度的做到了职责分离，避免大量的重复代码，在iOS和MacOS平台上交互方式有很大的不同，iOS中使用的是UIKit和UIView，在macOS中使用的则是appkit和NSView，这种情况下，将展示分离出来会给苹果的多平台系统开发带来便捷。

UIView其实已经封装好了很多关于layer的方法，但是layer还是有很多能力是UIView做不到的，比如常见的阴影，圆角，边框，3D变换，非矩形范围，透明遮罩，多级非线形动画。

一。layer的基本添加：BZSimpleLayerVC

二。layer身上的贴图--寄宿图 ：BZImageLayerVC

layer除了可以设置背景颜色以外，还可以设置一张图片，可以通过id类型的contents属性来设置这张图，我们给contents赋值任何值都能编译通过，但是它只接受CGImage类型的值，其他的都会显示空白，为什么要将其定义成泛型呢？因为在macOS中，CGImage和NSImage都起作用，但是在iOS中赋值UIImage给它将会无法显示。

要注意的一点是，即使我们将图片使用.CGImage进行设置也依然会报出编译错误，因为它返回的并不是真正意义上的CGImage类型，而是CGImageRef，因此要使用`(__bridge id _Nullable)`进行转换，可以像设置contentMode一样设置contentsGravity调整图片的显示方式。

三。layer的裁剪刀--maskToBounds：BZLayerClipVC

UIView会显示超出自己边界的图片，CALayer也一样，UIView可以设置clipsToBounds，而layer可以设置masksToBounds。contentsRect还可以设置剪裁区域，只不过这个剪裁区域是0-1之间，而不是根据坐标剪裁。

四。layer的绘制--CALayerDelegate：BZLayerDraw

当我们提交绘制内容超出了CALayer的范围，即使我们没有设置masksToBounds=YES，超出CALayer的部分依然不会显示，因为通过CALayerDelegate这种方式绘图的时候，并没有对超出边界外的内容提供支持

上面提到的绘制代理方法是不是很像UIView的-drewRect:方法呢？是的，其实UIView内部负责绘制的layer图层的代理其实就是UIView本身，也是就是说view.layer.delegate = view，相当于这样一个逻辑。而-drewRect:只不过是layer代理方法封装的产物。
但是UIView与CALayer不同的地方是，当UIView视图显示在屏幕上时，会立刻隐式调用内容重绘，此时会调用-drewRect:方法；而CALayer重绘需要我们显式调用，它并不会在显示在屏幕上时进行重绘，而是让开发者通过[layer display];手动控制重绘

## CALayer布局

UIView布局的三个重要属性，frame，bounds和center，CALayer同样也有这三个属性，只不过center在layer中叫做position。每当我们改变UIView中改变frame时，实际上改变的是视图中layer的frame，我们不能只改变UIView中的frame而不改变layer的frame，他们之间是同步的。

frame其实是一个虚拟属性，它是根据bounds，position和transform算出来的，改变其中任何一个值，frame就会发生变化，通常情况下frame的宽高和bounds是相同的，但是当改变了transform之后可能就不相同了。

一。CALayer的锚点
center和position都是设置UIView或者Layer在其父视图或者父图层坐标系统中的位置，从而确定当前视图在父视图或父图层中的位置，作为UIView这个点是其中心点，但是对于Layer可就不一定了。

在CALayer中有一个属性叫做`anchorPoint`，也就是锚点，但是在UIView中并没有被暴漏出来，UIView的position叫做center，因为这个center包含了position+anchorPoint，此时anchorPoint的值是默认中心点的位置。

> 可以把当前的Layer比做一张纸，我们使用图钉将这张纸钉在墙上，anchorPoint就是图钉穿过纸张的那个点，而position是定在墙上的那个点，锚点是相对于layer的，而position是相对于其父图层的。anchorPoint使用的坐标系和contentRect一样，左上角是0，0，右下角是1，1.

如果在position不变的情况下改变anchorPoint，此时会发生什么变化？继续利用上面的模型，相当于我们将图钉摘下，从纸的另一个位置穿过，然后重新扎回上次的位置。此时图钉在墙上的位置不变，但是纸张相对墙的位置却发生了变化，其实也就是frame发生了变化

当一个图层通过transform进行旋转的时候，图层所围绕的中心就是锚点。

二。辅助处理点击事件

CALayer不能独立的处理事件的响应，也不能直接的处理手势或者触摸事件，但是作为UIView的辅助，它还是会做一些辅助英雄该做的事情。

CALayer包含了两个方法：containsPoint和hitTest

containsPoint接收一个本图层下的CGPoint对象，如果在图层范围内，就返回YES，但是这样需要我们筑层遍历视图树，hitTest则会接收CGPoint返回包含这个坐标点的图层。
